---
title: what happens to CS majors when coding is solved
description: CS majors are not cooked, but they think they are
date: "2025-05-04"
---

> Disclaimer: This is advice I wish I had, and a collection of ideas I've read that I think are useful. That does not mean it will be useful for anyone else. It probably wont be.

By 2027 coding will likely be solved.

The reason being, all the top AI labs are in a race to create "AGI", but the fastest way to get there is to create models that accelerate AI research. Therefore, the main focus of the models is to increase the pace of improvement of the next models.

Consequentially, every new LLM release is exponentially better at something very important to AI research: coding.

And that might eventually lead to coding being solved. This is not supposed to be a true argument for why that is the case, for more supporting evidence read [ai-2027.com](https://ai-2027.com).

The main claim I want to make is that despite this fact, CS majors are not cooked (as is popular to say in self-deprecating jokes) or at the very least, demonstrate why all CS majors should be very aware of this possibility.

## What did coding solve anyways?

As a CS major you should probably already know the difference between software engineering and computer science. AI is only going to magnify their distinction.

Coding is a tool that literally anyone with a computer can take advantage of. However, historically most CS majors will fall into the more popular buckets of what it looks like to use that tool.

there are really only so many places cs majors go after school:

1. big tech
2. little tech (startup)
3. grad school
4. founder
5. government
6. content creator
7. non profit
8. unemployed
9. brand new field (ragequit)

From the perspective of most of these buckets, coding has a more specific definition and motivation: translating some business requirement into code that provides value to users.

Besides being a bottleneck to building AGI, coding is nothing more than a repeatable solution to business problems. If you have code to solve a problem once, you can charge others to use it nearly ad infinitum. Which is obviously why the role of "Software Engineer" has been so popular is recent history.

## Learning agency

So if your major is How to SWE, then you are certainly at risk. But good thing it's Computer Science.

In 2018, you could very easily get away with simply being good at any given popular tool like React. If you were skilled enough at that tool, you were immediately a better candidate. And you could get paid a shit ton for doing that. That obviously motivated most CS students out there to apply their skills to becoming great SWEs. Grinding Leetcode and putting out simple React portfolio projects could in many cases guarantee you a great job after school.

But that will no longer work. CS students are trained to look out towards and prepare for the next test they have to take. The format of the test is changing.

If coding is to be solved, then the value you provide can't simply be how effectively you can construct a solution to a predefined problem. Instead of thinking and wanting to become a SWE, you should strive to be more like a scientist. SWEs care about good tools and solutions. Scientists care about finding good problems and systems for solving them.

Being a CS major already gives you the core technical skills required to be a great scientist at heart: math, low-level programming, logic, systems. Combining these skills with real world, important problems is even better.

Depending on which of the earlier categories you care about most, you will be expected to find and be passionate about different types of problems. Maybe they are enterprise customer problems or environmental policy data report collecting. No matter what type, agency is your moat.

Having agency is what makes it possible to learn about a problem space, identify problems, hypothesize solutions, and create value. Code generating LLMs obviously cannot automate this cycle. Everything in that workflow relies on collaboration and humans.

Obsessing about good problems is what makes businesses or anything else on that list valuable to others.

So, this may read very high level and not very grounded in tangible changes CS majors can make to "ace" this new type of test. The main idea is that the act of coding was never really the end goal. Most software engineers are just small pieces of a larger organization implementing solutions to problems other people solved.

As CS majors it is more important now than ever to understand that coding alone is not very interesting, being a scientist is.

Helpful readings:

- [https://www.navalmanack.com](https://www.navalmanack.com/)
- [https://paulgraham.com/before.html](https://paulgraham.com/before.html)
- [https://www.cs.virginia.edu/~robins/YouAndYourResearch.html](https://www.cs.virginia.edu/~robins/YouAndYourResearch.html)

In the meantime:

- learn
  - literally anything that is interesting to you. the more topics you like + CS stuff the more unique your skillset is
- teach on your own platform
  - youtube, twitch, etc. in a world where most technical interviews can be cheated, teaching well proves understanding
- build for fun
- build something people want
  - this is really hard, but it proves your ability to complete the cycle I mentioned earlier

Even more specific:

- build a project specfically for a job you want to apply for
  - a new feature, some automation, etc. then email it directly to the ceo and cc the hiring manager
- pick the latest dev tool and build an open source project with it
  - most new dev tools really really want to be used and will repost anything you make with it
- do a directed study at your school
  - it's more driven by what you care about, than traditional research and it is also easier
